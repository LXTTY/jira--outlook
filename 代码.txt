import json
import logging
import time
import threading
from datetime import datetime
import win32com.client
import pythoncom
import requests
from requests.auth import HTTPBasicAuth
import re
import os
import uuid
import shutil
import mimetypes
from pathlib import Path

# é…ç½®æ—¥å¿—
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('email_to_jira.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


def load_config():
    """åŠ è½½é…ç½®æ–‡ä»¶"""
    try:
        with open('email_to_jira_config.json', 'r', encoding='utf-8') as f:
            config = json.load(f)
        logger.info("âœ… é…ç½®æ–‡ä»¶åŠ è½½æˆåŠŸ")
        return config
    except FileNotFoundError:
        logger.error("âŒ é…ç½®æ–‡ä»¶ 'email_to_jira_config.json' æœªæ‰¾åˆ°")
        return None
    except json.JSONDecodeError as e:
        logger.error(f"âŒ é…ç½®æ–‡ä»¶æ ¼å¼é”™è¯¯: {e}")
        return None


class EmailToJiraHandler:
    def __init__(self, config):
        self.config = config
        self.processed_emails = set()
        self.stop_event = threading.Event()

        # æŒ‡å®šè¦ç›‘æ§çš„é‚®ç®±
        self.target_email = "xingchungui@sylincom.com"

        # åˆå§‹åŒ–Outlookè¿æ¥
        self.outlook = None
        self.namespace = None
        self.inbox = None

        # åˆ›å»ºä¸´æ—¶ç¦å»ºç›®å½•
        self.temp_dir = Path(self.config['attachments']['temp_dir'])
        self.temp_dir.mkdir(exist_ok=True)
        self.load_processed_emails()

    def load_processed_emails(self):
        """åŠ è½½å·²å¤„ç†çš„é‚®ä»¶è®°å½•"""
        try:
            with open('processed_emails.json', 'r', encoding='utf-8') as f:
                data = json.load(f)
                self.processed_emails = set(data.get('processed_emails', []))
            logger.info(f"ğŸ“‹ åŠ è½½äº† {len(self.processed_emails)} ä¸ªå·²å¤„ç†é‚®ä»¶è®°å½•")
        except FileNotFoundError:
            logger.info("ğŸ“‹ æœªæ‰¾åˆ°å·²å¤„ç†é‚®ä»¶è®°å½•æ–‡ä»¶ï¼Œå°†åˆ›å»ºæ–°æ–‡ä»¶")
            self.processed_emails = set()
        except Exception as e:
            logger.error(f"åŠ è½½å·²å¤„ç†é‚®ä»¶è®°å½•å¤±è´¥: {e}")
            self.processed_emails = set()

    def save_processed_emails(self):
        """ä¿å­˜å·²å¤„ç†çš„é‚®ä»¶è®°å½•"""
        try:
            data = {'processed_emails': list(self.processed_emails)}
            with open('processed_emails.json', 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"ä¿å­˜å·²å¤„ç†é‚®ä»¶è®°å½•å¤±è´¥: {e}")

    def connect_to_outlook(self):
        """è¿æ¥åˆ°Outlookå¹¶è·å–æŒ‡å®šé‚®ç®±"""
        try:
            pythoncom.CoInitialize()
            self.outlook = win32com.client.Dispatch("Outlook.Application")
            self.namespace = self.outlook.GetNamespace("MAPI")

            logger.info(f"ğŸ” æ­£åœ¨è¿æ¥åˆ°é‚®ç®±: {self.target_email}")

            # æ–¹æ³•1ï¼šé€šè¿‡å…±äº«é‚®ç®±æ–¹å¼è®¿é—®
            try:
                recipient = self.namespace.CreateRecipient(self.target_email)
                recipient.Resolve()

                if recipient.Resolved:
                    shared_inbox = self.namespace.GetSharedDefaultFolder(recipient, 6)  # 6 = olFolderInbox
                    self.inbox = shared_inbox
                    logger.info(f"âœ… æˆåŠŸé€šè¿‡å…±äº«é‚®ç®±æ–¹å¼è¿æ¥åˆ°: {self.target_email}")
                    return True
                else:
                    logger.warning(f"âš ï¸ æ— æ³•è§£æé‚®ç®±åœ°å€: {self.target_email}")

            except Exception as e:
                logger.warning(f"âš ï¸ å…±äº«é‚®ç®±æ–¹å¼å¤±è´¥: {e}")

            # æ–¹æ³•2ï¼šéå†æ‰€æœ‰è´¦æˆ·æŸ¥æ‰¾ç›®æ ‡é‚®ç®±
            logger.info("ğŸ”„ å°è¯•éå†è´¦æˆ·æŸ¥æ‰¾ç›®æ ‡é‚®ç®±...")
            accounts = self.namespace.Accounts

            for i, account in enumerate(accounts):
                try:
                    account_email = getattr(account, 'SmtpAddress', '') or getattr(account, 'UserName', '')
                    display_name = getattr(account, 'DisplayName', f'è´¦æˆ·{i + 1}')

                    logger.info(f"  æ£€æŸ¥è´¦æˆ·: {display_name} ({account_email})")

                    if account_email.lower() == self.target_email.lower():
                        # æ‰¾åˆ°ç›®æ ‡è´¦æˆ·
                        logger.info(f"  âœ… æ‰¾åˆ°ç›®æ ‡è´¦æˆ·!")

                        delivery_store = account.DeliveryStore
                        root_folder = delivery_store.GetRootFolder()

                        # æŸ¥æ‰¾æ”¶ä»¶ç®±
                        for folder in root_folder.Folders:
                            folder_name = folder.Name.lower()
                            if folder_name in ['inbox', 'æ”¶ä»¶ç®±', 'inkomende berichten']:
                                self.inbox = folder
                                unread_count = folder.UnReadItemCount
                                total_count = folder.Items.Count
                                logger.info(f"âœ… æˆåŠŸè¿æ¥åˆ°æ”¶ä»¶ç®±: {folder.Name}")
                                logger.info(f"ğŸ“Š é‚®ç®±çŠ¶æ€ - æœªè¯»: {unread_count}, æ€»è®¡: {total_count}")
                                return True

                        logger.error(f"âŒ åœ¨è´¦æˆ·ä¸­æœªæ‰¾åˆ°æ”¶ä»¶ç®±æ–‡ä»¶å¤¹")

                except Exception as e:
                    logger.warning(f"  æ£€æŸ¥è´¦æˆ·æ—¶å‡ºé”™: {e}")
                    continue

            # æ–¹æ³•3ï¼šå¦‚æœæ˜¯é»˜è®¤è´¦æˆ·ï¼Œç›´æ¥ä½¿ç”¨é»˜è®¤æ”¶ä»¶ç®±
            try:
                logger.info("ğŸ”„ å°è¯•ä½¿ç”¨é»˜è®¤æ”¶ä»¶ç®±...")
                default_inbox = self.namespace.GetDefaultFolder(6)

                # æ£€æŸ¥é»˜è®¤è´¦æˆ·çš„é‚®ç®±åœ°å€
                try:
                    current_user = self.namespace.CurrentUser
                    if hasattr(current_user, 'Address'):
                        current_email = current_user.Address
                        logger.info(f"  é»˜è®¤è´¦æˆ·é‚®ç®±: {current_email}")

                        if current_email.lower() == self.target_email.lower():
                            self.inbox = default_inbox
                            unread_count = default_inbox.UnReadItemCount
                            total_count = default_inbox.Items.Count
                            logger.info(f"âœ… ä½¿ç”¨é»˜è®¤æ”¶ä»¶ç®±")
                            logger.info(f"ğŸ“Š é‚®ç®±çŠ¶æ€ - æœªè¯»: {unread_count}, æ€»è®¡: {total_count}")
                            return True
                except Exception as e:
                    logger.warning(f"  æ£€æŸ¥é»˜è®¤è´¦æˆ·å¤±è´¥: {e}")

                # å¦‚æœæ‰¾ä¸åˆ°åŒ¹é…çš„è´¦æˆ·ï¼Œè¯¢é—®æ˜¯å¦ä½¿ç”¨é»˜è®¤æ”¶ä»¶ç®±
                logger.warning(f"âš ï¸ æœªæ‰¾åˆ°åŒ¹é…çš„é‚®ç®±è´¦æˆ·")
                logger.info(f"ğŸ’¡ å°†ä½¿ç”¨é»˜è®¤æ”¶ä»¶ç®±è¿›è¡Œç›‘æ§")
                self.inbox = default_inbox
                unread_count = default_inbox.UnReadItemCount
                total_count = default_inbox.Items.Count
                logger.info(f"ğŸ“Š é»˜è®¤æ”¶ä»¶ç®±çŠ¶æ€ - æœªè¯»: {unread_count}, æ€»è®¡: {total_count}")
                return True

            except Exception as e:
                logger.error(f"âŒ è®¿é—®é»˜è®¤æ”¶ä»¶ç®±å¤±è´¥: {e}")

            logger.error(f"âŒ æ— æ³•è¿æ¥åˆ°ä»»ä½•æ”¶ä»¶ç®±")
            return False

        except Exception as e:
            logger.error(f"è¿æ¥Outlookå¤±è´¥: {e}")
            return False

    def is_target_email(self, mail):
        """åˆ¤æ–­æ˜¯å¦ä¸ºç›®æ ‡é‚®ä»¶ - æ£€æŸ¥æ˜¯å¦ä»¥@jiraå¼€å¤´"""
        try:
            body = mail.Body or ""
            subject = mail.Subject or ""
            sender = mail.SenderEmailAddress or ""

            logger.debug(f"    æ£€æŸ¥é‚®ä»¶:")
            logger.debug(f"    ä¸»é¢˜: '{subject}'")
            logger.debug(f"    å‘ä»¶äºº: '{sender}'")

            # æ£€æŸ¥é‚®ä»¶æ­£æ–‡æ˜¯å¦ä»¥@jiraå¼€å¤´
            body_stripped = body.strip()
            if body_stripped.lower().startswith('@jira'):
                logger.info(f"    âœ… é‚®ä»¶ä»¥@jiraå¼€å¤´ï¼Œç¬¦åˆå¤„ç†æ¡ä»¶")
                return True
            else:
                logger.info(f"    âŒ é‚®ä»¶æœªä»¥@jiraå¼€å¤´ï¼Œè·³è¿‡å¤„ç†")
                return False

        except Exception as e:
            logger.error(f"é‚®ä»¶è¿‡æ»¤æ£€æŸ¥å¼‚å¸¸: {e}")
            return False

    def scan_unread_emails(self, inbox):
        """æ‰«ææœªè¯»é‚®ä»¶"""
        try:
            # è·å–æœªè¯»é‚®ä»¶
            unread_emails = inbox.Items.Restrict("[UnRead] = True")
            unread_emails.Sort("[ReceivedTime]", True)

            count = unread_emails.Count
            current_time = datetime.now().strftime("%H:%M:%S")

            # æ€»æ˜¯æ˜¾ç¤ºæ‰«æçŠ¶æ€
            logger.info(f"[{current_time}] ğŸ“§ æ‰«æé‚®ä»¶: å‘ç° {count} å°æœªè¯»é‚®ä»¶")

            if count > 0:
                logger.info(f"å¼€å§‹é€ä¸ªæ£€æŸ¥é‚®ä»¶...")

                processed_count = 0
                for i, mail in enumerate(unread_emails):
                    if self.stop_event.is_set():
                        break

                    try:
                        subject = getattr(mail, 'Subject', 'æ— ä¸»é¢˜') or 'æ— ä¸»é¢˜'
                        sender = getattr(mail, 'SenderEmailAddress', 'æœªçŸ¥') or 'æœªçŸ¥'

                        logger.info(f"  é‚®ä»¶ {i + 1}: ä¸»é¢˜='{subject[:50]}...' å‘ä»¶äºº='{sender}'")

                        # æ£€æŸ¥æ˜¯å¦ä¸ºç›®æ ‡é‚®ä»¶ï¼ˆä»¥@jiraå¼€å¤´ï¼‰
                        is_target = self.is_target_email(mail)

                        if is_target:
                            if self.process_email(mail):
                                processed_count += 1

                    except Exception as e:
                        logger.error(f"  â†’ å¤„ç†é‚®ä»¶ {i + 1} æ—¶å‡ºé”™: {e}")

                if processed_count > 0:
                    logger.info(f"âœ… æœ¬æ¬¡å¤„ç†äº† {processed_count} å°é‚®ä»¶")
                    self.save_processed_emails()
                else:
                    logger.info(f"â„¹ï¸ æ²¡æœ‰é‚®ä»¶ç¬¦åˆå¤„ç†æ¡ä»¶")

                return processed_count
            else:
                # æ¯5åˆ†é’Ÿæ˜¾ç¤ºä¸€æ¬¡æ— é‚®ä»¶çŠ¶æ€
                if hasattr(self, '_last_no_mail_log'):
                    if (datetime.now() - self._last_no_mail_log).seconds >= 300:
                        logger.info(f"[{current_time}] ğŸ“­ å½“å‰æ— æœªè¯»é‚®ä»¶")
                        self._last_no_mail_log = datetime.now()
                else:
                    logger.info(f"[{current_time}] ğŸ“­ å½“å‰æ— æœªè¯»é‚®ä»¶")
                    self._last_no_mail_log = datetime.now()
                return 0

        except Exception as e:
            logger.error(f"æ‰«ææœªè¯»é‚®ä»¶å¼‚å¸¸: {e}")
            return 0

    def parse_email_params(self, body):
        """è§£æé‚®ä»¶å‚æ•°å¹¶æå–æœ‰æ•ˆå†…å®¹ - æ–°æ ¼å¼: @jira@é¡¹ç›®@ç»åŠäºº@é—®é¢˜ç±»å‹@å®Œæˆæ—¶é—´"""
        project = None
        assignee = None
        issue_type = None
        due_date = None
        remaining_body = body

        try:
            # ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…æ–°çš„å‚æ•°æ ¼å¼ï¼š@jira@é¡¹ç›®@ç»åŠäºº@é—®é¢˜ç±»å‹@å®Œæˆæ—¶é—´
            pattern = r'^@jira@([^@]*)@([^@]*)@([^@]*)@([^@]*)\s*\n'
            match = re.match(pattern, body, re.MULTILINE)

            if not match:
                # å°è¯•ä¸æ¢è¡Œçš„æƒ…å†µ
                pattern = r'^@jira@([^@]*)@([^@]*)@([^@]*)@([^@]*)'
                match = re.match(pattern, body)

            if match:
                project = self.clean_param(match.group(1))
                assignee = self.clean_param(match.group(2))
                issue_type = self.clean_param(match.group(3))
                due_date = self.clean_param(match.group(4))

                # ç§»é™¤å‚æ•°è¡Œ,è·å–å‰©ä½™æ­£æ–‡
                remaining_body = body[match.end():].strip()

                logger.info(f"    ğŸ“‹ è§£æ@jiraå‚æ•°æˆåŠŸ:")
                logger.info(f"      é¡¹ç›®: {project}")
                logger.info(f"      ç»åŠäºº: {assignee}")
                logger.info(f"      é—®é¢˜ç±»å‹: {issue_type}")
                logger.info(f"      å®Œæˆæ—¶é—´: {due_date}")
            else:
                logger.warning(f"    âš ï¸ æœªæ‰¾åˆ°å®Œæ•´çš„@jiraå‚æ•°æ ¼å¼ï¼Œä½¿ç”¨é»˜è®¤å€¼")
                # å¦‚æœæ²¡æœ‰æ‰¾åˆ°å®Œæ•´æ ¼å¼ï¼Œä½†é‚®ä»¶ä»¥@jiraå¼€å¤´ï¼Œç§»é™¤@jiraæ ‡è®°
                if body.strip().lower().startswith('@jira'):
                    # æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ¢è¡Œç¬¦æˆ–@jiraåçš„å†…å®¹
                    lines = body.split('\n')
                    if len(lines) > 1:
                        remaining_body = '\n'.join(lines[1:]).strip()
                    else:
                        # å¦‚æœæ²¡æœ‰æ¢è¡Œï¼Œå°è¯•ç§»é™¤@jira
                        remaining_body = body[5:].strip()  # ç§»é™¤@jira

            # ä»å‰©ä½™æ­£æ–‡ä¸­æå–##æ ‡è®°å†…å®¹
            valid_content = self.extract_content_between_markers(remaining_body)

            logger.info(f"    ğŸ“ æœ‰æ•ˆå†…å®¹é•¿åº¦: {len(valid_content)} å­—ç¬¦")

            return project, assignee, issue_type, due_date, valid_content

        except Exception as e:
            logger.error(f"è§£æé‚®ä»¶å‚æ•°å¤±è´¥: {e}")
            # å¦‚æœè§£æå¤±è´¥ï¼Œè‡³å°‘å°è¯•æå–##æ ‡è®°å†…å®¹
            valid_content = self.extract_content_between_markers(body)
            return None, None, None, None, valid_content

    def clean_param(self, param):
        """æ¸…ç†å‚æ•°ï¼Œå»é™¤ç©ºæ ¼å’Œæ¢è¡Œç¬¦"""
        if param:
            return param.strip()
        return None

    def parse_due_date(self, date_str):
        """
        è§£æå®Œæˆæ—¶é—´ä¸ºæ ‡å‡†æ ¼å¼ï¼ˆç”¨äºæ˜¾ç¤ºï¼‰

        Args:
            date_str: æ—¶é—´å­—ç¬¦ä¸²

        Returns:
            str: æ ‡å‡†æ ¼å¼çš„æ—¥æœŸå­—ç¬¦ä¸² (YYYY-MM-DD) æˆ– None
        """
        if not date_str:
            return None

        try:
            # æ”¯æŒçš„æ—¥æœŸæ ¼å¼
            date_formats = [
                '%Y-%m-%d',  # 2025-06-04
                '%Y/%m/%d',  # 2025/06/04
                '%Y.%m.%d',  # 2025.06.04
                '%m/%d/%Y',  # 06/04/2025
                '%d/%m/%Y',  # 04/06/2025
                '%Yå¹´%mæœˆ%dæ—¥',  # 2025å¹´06æœˆ04æ—¥
                '%mæœˆ%dæ—¥',  # 06æœˆ04æ—¥
                '%m-%d'  # 06-04
            ]

            for fmt in date_formats:
                try:
                    if fmt == '%m-%d':
                        # å¯¹äºåªæœ‰æœˆæ—¥çš„æ ¼å¼ï¼Œä½¿ç”¨å½“å‰å¹´ä»½
                        parsed_date = datetime.strptime(date_str, fmt)
                        current_year = datetime.now().year
                        parsed_date = parsed_date.replace(year=current_year)
                    elif fmt == '%mæœˆ%dæ—¥':
                        # å¯¹äºä¸­æ–‡æœˆæ—¥æ ¼å¼ï¼Œä½¿ç”¨å½“å‰å¹´ä»½
                        parsed_date = datetime.strptime(date_str, fmt)
                        current_year = datetime.now().year
                        parsed_date = parsed_date.replace(year=current_year)
                    else:
                        parsed_date = datetime.strptime(date_str, fmt)

                    result = parsed_date.strftime('%Y-%m-%d')
                    logger.info(f"    âœ… æ—¥æœŸè§£ææˆåŠŸ: {date_str} -> {result}")
                    return result

                except ValueError:
                    continue

            logger.warning(f"    âš ï¸ æ— æ³•è§£ææ—¥æœŸæ ¼å¼: {date_str}ï¼Œå°†ä½¿ç”¨åŸå§‹æ ¼å¼")
            return None

        except Exception as e:
            logger.warning(f"    âš ï¸ æ—¥æœŸè§£æé”™è¯¯: {e}")
            return None

    def extract_attachments(self, mail):
        """æå–é‚®ä»¶é™„ä»¶"""
        attachments_info = []

        if not self.config['attachments']['enabled']:
            return attachments_info

        try:
            attachment_count = mail.Attachments.Count
            if attachment_count == 0:
                return attachments_info

            logger.info(f"    ğŸ“ å‘ç° {attachment_count} ä¸ªé™„ä»¶")

            # æ£€æŸ¥é™„ä»¶æ•°é‡é™åˆ¶
            max_count = self.config['attachments']['max_count']
            if attachment_count > max_count:
                logger.warning(f"    âš ï¸ é™„ä»¶æ•°é‡ ({attachment_count}) è¶…è¿‡é™åˆ¶ ({max_count})ï¼Œåªå¤„ç†å‰ {max_count} ä¸ª")
                attachment_count = max_count

            # åˆ›å»ºæœ¬æ¬¡é‚®ä»¶çš„ä¸´æ—¶ç›®å½•
            email_temp_dir = self.temp_dir / str(uuid.uuid4())
            email_temp_dir.mkdir(exist_ok=True)

            for i in range(1, attachment_count + 1):
                try:
                    attachment = mail.Attachments.Item(i)
                    attachment_info = self.process_single_attachment(attachment, email_temp_dir, i)

                    if attachment_info:
                        attachments_info.append(attachment_info)

                except Exception as e:
                    logger.error(f"    âŒ å¤„ç†ç¬¬ {i} ä¸ªé™„ä»¶å¤±è´¥: {e}")
                    continue

            logger.info(f"    âœ… æˆåŠŸæå– {len(attachments_info)} ä¸ªé™„ä»¶")

        except Exception as e:
            logger.error(f"æå–é™„ä»¶å¼‚å¸¸: {e}")

        return attachments_info

    def process_single_attachment(self, attachment, temp_dir, index):
        """å¤„ç†å•ä¸ªé™„ä»¶"""
        try:
            filename = attachment.FileName
            file_size = attachment.Size

            logger.info(f"      ğŸ“„ å¤„ç†é™„ä»¶ {index}: {filename} ({self.format_file_size(file_size)})")

            # æ£€æŸ¥æ–‡ä»¶æ‰©å±•å
            file_ext = Path(filename).suffix.lower()
            allowed_extensions = [ext.lower() for ext in self.config['attachments']['allowed_extensions']]

            if file_ext not in allowed_extensions:
                logger.warning(f"      âš ï¸ è·³è¿‡ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: {file_ext}")
                return None

            # æ£€æŸ¥æ–‡ä»¶å¤§å°
            max_size_bytes = self.config['attachments']['max_size_mb'] * 1024 * 1024
            if file_size > max_size_bytes:
                logger.warning(
                    f"      âš ï¸ æ–‡ä»¶è¿‡å¤§ï¼Œè·³è¿‡: {self.format_file_size(file_size)} > {self.format_file_size(max_size_bytes)}")
                return None

            # ç”Ÿæˆå®‰å…¨çš„æ–‡ä»¶å
            safe_filename = self.generate_safe_filename(filename)
            file_path = temp_dir / safe_filename

            # ä¿å­˜é™„ä»¶
            attachment.SaveAsFile(str(file_path))

            # éªŒè¯æ–‡ä»¶æ˜¯å¦ä¿å­˜æˆåŠŸ
            if not file_path.exists():
                logger.error(f"      âŒ é™„ä»¶ä¿å­˜å¤±è´¥: {filename}")
                return None

            logger.info(f"      âœ… é™„ä»¶ä¿å­˜æˆåŠŸ: {safe_filename}")

            return {
                'original_name': filename,
                'safe_name': safe_filename,
                'file_path': file_path,
                'size': file_size,
                'mime_type': mimetypes.guess_type(filename)[0] or 'application/octet-stream'
            }

        except Exception as e:
            logger.error(f"      âŒ å¤„ç†é™„ä»¶ {filename} å¼‚å¸¸: {e}")
            return None

    def generate_safe_filename(self, filename):
        """ç”Ÿæˆå®‰å…¨çš„æ–‡ä»¶å"""
        # ç§»é™¤å±é™©å­—ç¬¦
        safe_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-_()[]"
        safe_name = ''.join(c if c in safe_chars else '_' for c in filename)

        # å¦‚æœæ–‡ä»¶åå¤ªé•¿ï¼Œæˆªæ–­ä½†ä¿ç•™æ‰©å±•å
        if len(safe_name) > 100:
            name_part = Path(safe_name).stem[:90]
            ext_part = Path(safe_name).suffix
            safe_name = name_part + ext_part

        # æ·»åŠ æ—¶é—´æˆ³é¿å…å†²çª
        timestamp = int(time.time())
        name_part = Path(safe_name).stem
        ext_part = Path(safe_name).suffix

        return f"{name_part}_{timestamp}{ext_part}"

    def format_file_size(self, size_bytes):
        """æ ¼å¼åŒ–æ–‡ä»¶å¤§å°"""
        if size_bytes < 1024:
            return f"{size_bytes} B"
        elif size_bytes < 1024 * 1024:
            return f"{size_bytes / 1024:.1f} KB"
        else:
            return f"{size_bytes / (1024 * 1024):.1f} MB"

    def upload_attachments_to_jira(self, issue_key, attachments_info):
        """ä¸Šä¼ é™„ä»¶åˆ°Jira"""
        if not attachments_info:
            return True

        try:
            base_url = f"{self.config['jira']['base_url']}/rest/api/2/issue/{issue_key}/attachments"
            auth = HTTPBasicAuth(
                self.config['jira']['username'],
                self.config['jira']['password']
            )

            logger.info(f"    ğŸ“¤ å¼€å§‹ä¸Šä¼  {len(attachments_info)} ä¸ªé™„ä»¶åˆ° {issue_key}")

            success_count = 0

            for i, attachment_info in enumerate(attachments_info, 1):
                try:
                    logger.info(f"      ğŸ”„ ä¸Šä¼ é™„ä»¶ {i}/{len(attachments_info)}: {attachment_info['original_name']}")

                    # å‡†å¤‡æ–‡ä»¶ä¸Šä¼ 
                    with open(attachment_info['file_path'], 'rb') as file:
                        files = {
                            'file': (
                                attachment_info['original_name'],
                                file,
                                attachment_info['mime_type']
                            )
                        }

                        headers = {
                            'X-Atlassian-Token': 'no-check'  # Jiraè¦æ±‚çš„CSRFä¿æŠ¤
                        }

                        response = requests.post(
                            base_url,
                            files=files,
                            auth=auth,
                            headers=headers
                        )

                        if response.status_code == 200:
                            logger.info(f"      âœ… é™„ä»¶ä¸Šä¼ æˆåŠŸ: {attachment_info['original_name']}")
                            success_count += 1
                        else:
                            logger.error(f"      âŒ é™„ä»¶ä¸Šä¼ å¤±è´¥: {response.status_code}")
                            logger.error(f"      å“åº”å†…å®¹: {response.text}")

                except Exception as e:
                    logger.error(f"      âŒ ä¸Šä¼ é™„ä»¶ {attachment_info['original_name']} å¼‚å¸¸: {e}")
                    continue

            logger.info(f"    ğŸ“Š é™„ä»¶ä¸Šä¼ å®Œæˆ: {success_count}/{len(attachments_info)} æˆåŠŸ")
            return success_count > 0

        except Exception as e:
            logger.error(f"ä¸Šä¼ é™„ä»¶åˆ°Jiraå¼‚å¸¸: {e}")
            return False

    def cleanup_attachments(self, attachments_info):
        """æ¸…ç†ä¸´æ—¶é™„ä»¶æ–‡ä»¶"""
        try:
            if not attachments_info:
                return

            # è·å–ä¸´æ—¶ç›®å½•ï¼ˆæ‰€æœ‰é™„ä»¶åº”è¯¥åœ¨åŒä¸€ä¸ªä¸´æ—¶ç›®å½•ä¸­ï¼‰
            temp_dirs = set()
            for attachment_info in attachments_info:
                temp_dirs.add(attachment_info['file_path'].parent)

            # åˆ é™¤ä¸´æ—¶ç›®å½•
            for temp_dir in temp_dirs:
                if temp_dir.exists():
                    shutil.rmtree(temp_dir)
                    logger.debug(f"    ğŸ—‘ï¸ å·²æ¸…ç†ä¸´æ—¶ç›®å½•: {temp_dir}")

        except Exception as e:
            logger.error(f"æ¸…ç†é™„ä»¶æ–‡ä»¶å¼‚å¸¸: {e}")

    def create_jira_issue_with_attachments(self, subject, sender, body, received_time, mail,
                                           project=None, assignee=None, issue_type=None, due_date=None):
        """åˆ›å»ºJiraç¼ºé™·å¹¶ä¸Šä¼ é™„ä»¶ - æ”¯æŒåŠ¨æ€å‚æ•°"""
        try:
            # 1. æå–é™„ä»¶
            attachments_info = self.extract_attachments(mail)

            # 2. æ„å»ºæè¿°ï¼ˆåŒ…å«é™„ä»¶ä¿¡æ¯å’Œå‚æ•°ä¿¡æ¯ï¼‰
            description = self.build_issue_description(subject=subject, sender=sender, body=body, received_time=received_time, attachments_info=attachments_info,
                                                       project=project, assignee=assignee, issue_type=issue_type, due_date=due_date)

            # 3. åˆ›å»ºJiraé—®é¢˜
            issue_key = self.create_jira_issue_only(subject, description, project, assignee, issue_type, due_date)

            if not issue_key:
                # åˆ›å»ºå¤±è´¥ï¼Œæ¸…ç†é™„ä»¶
                self.cleanup_attachments(attachments_info)
                return False

            # 4. ä¸Šä¼ é™„ä»¶
            upload_success = True
            if attachments_info:
                upload_success = self.upload_attachments_to_jira(issue_key, attachments_info)

            # 5. æ¸…ç†ä¸´æ—¶æ–‡ä»¶
            self.cleanup_attachments(attachments_info)

            # 6. æ˜¾ç¤ºç»“æœ
            issue_base_url = f"{self.config['jira']['base_url']}/browse/{issue_key}"
            logger.info(f"    ğŸ”— ç¼ºé™·é“¾æ¥: {issue_base_url}")

            if attachments_info and upload_success:
                logger.info(f"    ğŸ“ é™„ä»¶ä¸Šä¼ å®Œæˆ")
            elif attachments_info and not upload_success:
                logger.warning(f"    âš ï¸ ç¼ºé™·åˆ›å»ºæˆåŠŸï¼Œä½†éƒ¨åˆ†é™„ä»¶ä¸Šä¼ å¤±è´¥")

            return True

        except Exception as e:
            logger.error(f"åˆ›å»ºJiraç¼ºé™·å¼‚å¸¸: {e}")
            return False

    def build_issue_description(self, subject, sender, body, received_time, attachments_info,
                                project=None, assignee=None, issue_type=None, due_date=None):
        """æ„å»ºé—®é¢˜æè¿° - æå–æœ‰æ•ˆå†…å®¹å¹¶æ ¼å¼åŒ–"""
        try:
            logger.info(f"ğŸ” å¼€å§‹æ„å»ºæè¿°...")
            logger.info(f"    ğŸ“§ åŸå§‹bodyé•¿åº¦: {len(body) if body else 0}")
            logger.info(f"    ğŸ“§ åŸå§‹bodyå†…å®¹: {repr(body[:200]) if body else 'None'}...")

            # è°ƒç”¨extract_connect_between_markersæå–##æ ‡è®°ä¹‹é—´çš„æœ‰æ•ˆå†…å®¹
            valid_content = self.extract_content_between_markers(body)
            logger.info(f"    ğŸ“ æœ‰æ•ˆå†…å®¹é•¿åº¦: {len(valid_content) if valid_content else 0}")
            logger.info(f"    ğŸ“ æœ‰æ•ˆå†…å®¹: {repr(valid_content[:200]) if valid_content else 'None'}...")

            description_parts = []

            # æ·»åŠ å®Œæˆæ—¶é—´ï¼ˆå¦‚æœæœ‰ï¼‰
            if due_date:
                parsed_due_date = self.parse_due_date(due_date)
                if parsed_due_date:
                    description_parts.append(f"ğŸ“… å®Œæˆæ—¶é—´: {parsed_due_date}")
                    logger.info(f"    âœ… å®Œæˆæ—¶é—´å·²æ·»åŠ : {parsed_due_date}")
                else:
                    description_parts.append(f"ğŸ“… å®Œæˆæ—¶é—´: {due_date}")
                    logger.info(f"    âœ… å®Œæˆæ—¶é—´å·²æ·»åŠ (åŸå§‹): {due_date}")
                description_parts.append("")  # æ·»åŠ ç©ºè¡Œ

            # æ·»åŠ æœ‰æ•ˆå†…å®¹
            if valid_content and valid_content.strip():
                description_parts.append(valid_content.strip())
                logger.info(f"    âœ… æœ‰æ•ˆå†…å®¹å·²æ·»åŠ ")
            else:
                description_parts.append("å†…å®¹ä¸ºç©ºæˆ–æ— ##æ ‡è®°å†…å®¹")
                logger.warning(f"    âš ï¸ æœ‰æ•ˆå†…å®¹ä¸ºç©ºï¼Œä½¿ç”¨é»˜è®¤æ–‡æœ¬")

            # å¦‚æœæœ‰é™„ä»¶ï¼Œæ·»åŠ é™„ä»¶ä¿¡æ¯
            if attachments_info:
                description_parts.append("")  # æ·»åŠ ç©ºè¡Œ
                description_parts.append("*é™„ä»¶ä¿¡æ¯:*")
                for attachment in attachments_info:
                    try:
                        filename = attachment.get('original_name', 'æœªçŸ¥æ–‡ä»¶å')
                        size = attachment.get('size', 0)
                        formatted_size = self.format_file_size(size)
                        description_parts.append(f"â€¢ {filename} ({formatted_size})")
                    except Exception as e:
                        logger.warning(f"è®¿é—®é™„ä»¶ä¿¡æ¯å¤±è´¥: {e}")
                        description_parts.append(f"â€¢ é™„ä»¶ä¿¡æ¯è¯»å–å¤±è´¥")

            final_description = "\n".join(description_parts)

            logger.info(f"ğŸ” æœ€ç»ˆæè¿°é•¿åº¦: {len(final_description)} å­—ç¬¦")
            logger.info(f"ğŸ“ æœ€ç»ˆæè¿°å®Œæ•´å†…å®¹: {repr(final_description)}")

            return final_description

        except Exception as e:
            logger.error(f"æ„å»ºé—®é¢˜æè¿°æ—¶å‘ç”Ÿå¼‚å¸¸: {e}")
            import traceback
            logger.error(f"è¯¦ç»†é”™è¯¯ä¿¡æ¯: {traceback.format_exc()}")

            # è¿”å›ç®€åŒ–çš„æè¿°
            fallback_description = f"é‚®ä»¶å†…å®¹å¤„ç†å¼‚å¸¸: {str(e)}"
            if due_date:
                fallback_description = f"ğŸ“… å®Œæˆæ—¶é—´: {due_date}\n\n{fallback_description}"

            logger.info(f"ğŸ“ ä½¿ç”¨å¤‡ç”¨æè¿°: {repr(fallback_description)}")
            return fallback_description

    def extract_content_between_markers(self, content):
        """
        æå–##æ ‡è®°ä¹‹é—´çš„æœ‰æ•ˆå†…å®¹
        """
        import re

        if not content:
            logger.warning("    âš ï¸ å†…å®¹ä¸ºç©º")
            return "å†…å®¹ä¸ºç©º"

        logger.info(f"    ğŸ” å¼€å§‹æå–##æ ‡è®°å†…å®¹...")
        logger.info(f"    ğŸ“„ å¾…å¤„ç†å†…å®¹å‰200å­—ç¬¦: {content[:200]}")

        # åŒ¹é… ##ä»»æ„å†…å®¹## æ ¼å¼ï¼Œæ”¯æŒå¤šè¡Œ
        pattern = r'##(.*?)##'
        matches = re.findall(pattern, content, re.DOTALL)

        if matches:
            # åˆå¹¶æ‰€æœ‰åŒ¹é…çš„å†…å®¹
            valid_content = '\n\n'.join(match.strip() for match in matches if match.strip())
            logger.info(f"    âœ… æˆåŠŸæå–##æ ‡è®°å†…å®¹: {len(valid_content)} å­—ç¬¦")
            logger.info(f"    ğŸ“ æå–å†…å®¹: {valid_content}")
            return valid_content
        else:
            logger.warning(f"    âš ï¸ æœªæ‰¾åˆ°##æ ‡è®°ï¼Œè¿”å›åŸå†…å®¹")
            logger.info(f"    ğŸ“„ åŸå†…å®¹: {content}")
            return content  # å¦‚æœæ²¡æœ‰##æ ‡è®°ï¼Œè¿”å›åŸå†…å®¹

    def create_jira_issue_only(self, subject, description, project=None, assignee=None, issue_type=None, due_date=None):
        """ä»…åˆ›å»ºJiraé—®é¢˜ - åŒ…å«æ‰€æœ‰å¿…å¡«å­—æ®µ"""
        try:
            # ä½¿ç”¨ä¼ å…¥çš„å‚æ•°æˆ–é…ç½®æ–‡ä»¶ä¸­çš„é»˜è®¤å€¼
            final_project = project or self.config['jira']['project']
            final_issue_type_id = self.config['jira'].get('issue_type_id', '10004')
            final_description = self.extract_content_between_markers(description)
            
            # è·å–å½“å‰æ—¶é—´ä½œä¸ºé¢„è®¡å¼€å§‹æ—¶é—´
            from datetime import datetime, timedelta
            start_date = datetime.now().strftime('%Y-%m-%d')

            # è®¡ç®—é¢„è®¡å®Œæˆæ—¶é—´ï¼ˆé»˜è®¤7å¤©åï¼Œæˆ–ä½¿ç”¨due_dateï¼‰
            if due_date:
                end_date = self.parse_due_date(due_date) or due_date
            else:
                end_date = (datetime.now() + timedelta(days=7)).strftime('%Y-%m-%d')

            # æ„å»ºissueæ•°æ® - åŒ…å«æ‰€æœ‰å¿…å¡«å­—æ®µ
            issue_data = {
                'fields': {
                    # åŸºæœ¬å¿…å¡«å­—æ®µ
                    'project': {'key': final_project},  # é¡¹ç›®
                    'summary': subject,  # æ¦‚è¦
                    'description': final_description,  # æè¿°
                    'issuetype': {'id': final_issue_type_id},  # é—®é¢˜ç±»å‹

                    # æ—¶é—´ç›¸å…³å­—æ®µ
                    'customfield_10127': start_date,  # é¢„è®¡å¼€å§‹æ—¶é—´
                    'customfield_10128': end_date,  # é¢„è®¡å®Œæˆæ—¶é—´
                    'customfield_10403': self.config['jira'].get('default_completion_criteria', 'é—®é¢˜è§£å†³å¹¶éªŒè¯é€šè¿‡'),
                    # å®ŒæˆæŒ‡æ ‡

                    # æ–°å¢çš„å¿…å¡«å­—æ®µ
                    'customfield_10414': self.config['jira'].get('default_department', 'ITéƒ¨é—¨'),  # æ‰€å±éƒ¨é—¨
                    'customfield_10417': self.config['jira'].get('default_module', 'ç³»ç»Ÿç»´æŠ¤'),  # é—®é¢˜æ¨¡å—
                    'customfield_10418': self.config['jira'].get('default_category', 'ç¼ºé™·ä¿®å¤'),  # é—®é¢˜ç±»åˆ«
                }
            }

            # å¦‚æœæŒ‡å®šäº†ç»åŠäºº
            if assignee:
                issue_data['fields']['assignee'] = {'name': assignee}

            logger.info(f"ğŸš€ å‡†å¤‡åˆ›å»ºJiraé—®é¢˜:")
            logger.info(f"   é¡¹ç›®: {final_project}")
            logger.info(f"   æ ‡é¢˜: {subject}")
            logger.info(f"   é—®é¢˜ç±»å‹ID: {final_issue_type_id}")
            logger.info(f"   ç»åŠäºº: {assignee}")
            logger.info(f"   é¢„è®¡å¼€å§‹æ—¶é—´: {start_date}")
            logger.info(f"   é¢„è®¡å®Œæˆæ—¶é—´: {end_date}")
            logger.info(f"   å®ŒæˆæŒ‡æ ‡: {issue_data['fields']['customfield_10403']}")
            logger.info(f"   æ‰€å±éƒ¨é—¨: {issue_data['fields']['customfield_10414']}")
            logger.info(f"   é—®é¢˜æ¨¡å—: {issue_data['fields']['customfield_10417']}")
            logger.info(f"   é—®é¢˜ç±»åˆ«: {issue_data['fields']['customfield_10418']}")

            # åˆ›å»ºé—®é¢˜
            response = requests.post(
                f"{self.config['jira']['base_url']}/rest/api/2/issue",
                json=issue_data,
                auth=(self.config['jira']['username'], self.config['jira']['password']),
                headers={'Content-Type': 'application/json'}
            )

            if response.status_code == 201:
                issue_key = response.json()['key']
                issue_url = f"{self.config['jira']['base_url']}/browse/{issue_key}"
                logger.info(f"âœ… Jiraé—®é¢˜åˆ›å»ºæˆåŠŸ!")
                logger.info(f"   é—®é¢˜ç¼–å·: {issue_key}")
                logger.info(f"   è®¿é—®é“¾æ¥: {issue_url}")
                return issue_key
            else:
                logger.error(f"âŒ åˆ›å»ºJiraç¼ºé™·å¤±è´¥: {response.status_code}")
                logger.error(f"å“åº”å†…å®¹: {response.text}")

                # è§£æé”™è¯¯ä¿¡æ¯ï¼Œæ˜¾ç¤ºç¼ºå°‘çš„å­—æ®µ
                try:
                    error_data = response.json()
                    if 'errors' in error_data:
                        logger.error("ç¼ºå°‘çš„å¿…å¡«å­—æ®µ:")
                        for field, message in error_data['errors'].items():
                            logger.error(f"  - {field}: {message}")
                except:
                    pass

                return None

        except Exception as e:
            logger.error(f"åˆ›å»ºJiraç¼ºé™·å¼‚å¸¸: {e}")
            import traceback
            logger.error(f"è¯¦ç»†é”™è¯¯: {traceback.format_exc()}")
            return None

    def get_start_date(self):
        """è·å–é¢„è®¡å¼€å§‹æ—¶é—´ï¼ˆé»˜è®¤ä¸ºä»Šå¤©ï¼‰"""
        from datetime import datetime
        return datetime.now().strftime('%Y-%m-%d')

    def get_end_date(self, due_date=None):
        """è·å–é¢„è®¡å®Œæˆæ—¶é—´"""
        if due_date:
            # å¦‚æœæä¾›äº†æˆªæ­¢æ—¥æœŸï¼Œä½¿ç”¨å®ƒ
            parsed_date = self.parse_due_date(due_date)
            return parsed_date if parsed_date else due_date
        else:
            # é»˜è®¤è®¾ç½®ä¸º7å¤©å
            from datetime import datetime, timedelta
            return (datetime.now() + timedelta(days=7)).strftime('%Y-%m-%d')

    def process_email(self, mail):
        """å¤„ç†é‚®ä»¶ - æ”¯æŒ@jiraå‚æ•°è§£æ"""
        try:
            subject = mail.Subject or "æ— ä¸»é¢˜"
            sender = mail.SenderEmailAddress
            body = mail.Body or ""
            received_time = mail.ReceivedTime.strftime("%Y-%m-%d %H:%M:%S")

            logger.info(f"  ğŸ“§ å¤„ç†é‚®ä»¶: {subject}")
            logger.info(f"    ğŸ‘¤ å‘ä»¶äºº: {sender}")
            logger.info(f"    ğŸ•’ æ—¶é—´: {received_time}")

            # è§£æ@jiraé‚®ä»¶å‚æ•°
            project, assignee, issue_type, due_date, valid_content = self.parse_email_params(body)

            # åˆ›å»ºJiraç¼ºé™·å¹¶å¤„ç†é™„ä»¶ï¼ˆä¼ å…¥è§£æçš„å‚æ•°ï¼‰
            success = self.create_jira_issue_with_attachments(
                subject, sender, valid_content, received_time, mail,
                project=project, assignee=assignee, issue_type=issue_type, due_date=due_date
            )

            if success:
                # æ ‡è®°ä¸ºå·²è¯»
                if self.config.get('mark_as_read', True):
                    mail.UnRead = False
                    logger.info(f"    âœ… é‚®ä»¶å·²æ ‡è®°ä¸ºå·²è¯»")

                return True
            else:
                logger.error(f"    âŒ å¤„ç†é‚®ä»¶å¤±è´¥")
                return False

        except Exception as e:
            logger.error(f"å¤„ç†é‚®ä»¶å¼‚å¸¸: {e}")
            return False

    def __del__(self):
        """ææ„å‡½æ•° - æ¸…ç†ä¸´æ—¶ç›®å½•"""
        try:
            if hasattr(self, 'temp_dir') and self.temp_dir.exists():
                shutil.rmtree(self.temp_dir, ignore_errors=True)
        except:
            pass

    def test_jira_connection(self):
        """æµ‹è¯•Jiraè¿æ¥"""
        try:
            base_url = f"{self.config['jira']['base_url']}/rest/api/2/myself"
            auth = HTTPBasicAuth(
                self.config['jira']['username'],
                self.config['jira']['password']
            )

            response = requests.get(base_url, auth=auth)

            if response.status_code == 200:
                user_info = response.json()
                logger.info(f"âœ… Jiraè¿æ¥æˆåŠŸï¼Œå½“å‰ç”¨æˆ·: {user_info.get('displayName', 'Unknown')}")

                # éªŒè¯é¡¹ç›®è®¿é—®æƒé™
                project_base_url = f"{self.config['jira']['base_url']}/rest/api/2/project/{self.config['jira']['project']}"
                project_response = requests.get(project_base_url, auth=auth)

                if project_response.status_code == 200:
                    project_info = project_response.json()
                    logger.info(
                        f"âœ… é¡¹ç›® {self.config['jira']['project']} è¿æ¥æˆåŠŸ: {project_info.get('name', 'Unknown')}")
                    return True
                else:
                    logger.error(f"âŒ æ— æ³•è®¿é—®é¡¹ç›® {self.config['jira']['project']}: {project_response.status_code}")
                    return False
            else:
                logger.error(f"âŒ Jiraè¿æ¥å¤±è´¥: {response.status_code}")
                return False

        except Exception as e:
            logger.error(f"æµ‹è¯•Jiraè¿æ¥å¼‚å¸¸: {e}")
            return False

    def test_outlook_connection(self):
        """æµ‹è¯•Outlookè¿æ¥"""
        return self.connect_to_outlook()

    def start_monitoring(self):
        """å¯åŠ¨é‚®ä»¶ç›‘æ§"""
        self.run_monitor()

    def stop_monitoring(self):
        """åœæ­¢é‚®ä»¶ç›‘æ§"""
        self.stop_event.set()

    def run_monitor(self):
        """è¿è¡Œé‚®ä»¶ç›‘æ§"""
        if not self.connect_to_outlook():
            logger.error("æ— æ³•è¿æ¥åˆ°Outlookï¼Œç¨‹åºé€€å‡º")
            return

        if not self.inbox:
            logger.error("æ— æ³•è·å–æ”¶ä»¶ç®±ï¼Œç¨‹åºé€€å‡º")
            return

        logger.info(f"ğŸ“§ å¼€å§‹ç›‘æ§é‚®ç®±: {self.target_email}")
        logger.info(f"â° æ£€æŸ¥é—´éš”: {self.config['monitor']['check_interval']}ç§’")
        logger.info(f"ğŸ¯ è§¦å‘æ¡ä»¶: é‚®ä»¶ä»¥@jiraå¼€å¤´")
        logger.info("ğŸ”„ ç›‘æ§å·²å¯åŠ¨ï¼Œç­‰å¾…é‚®ä»¶...")

        # æ˜¾ç¤º@jiraå‚æ•°è§£æåŠŸèƒ½çŠ¶æ€
        logger.info("ğŸ“‹ æ”¯æŒé‚®ä»¶å‚æ•°æ ¼å¼: @jira@é¡¹ç›®@ç»åŠäºº@é—®é¢˜ç±»å‹@å®Œæˆæ—¶é—´")
        logger.info("ğŸ’¡ ç¤ºä¾‹: @jira@S702@å¼ ä¸‰@ç¼ºé™·@2024-12-31")
        logger.info("ğŸ“ å†…å®¹æ ¼å¼: ##å®é™…é—®é¢˜æè¿°å†…å®¹##")

        while not self.stop_event.is_set():
            try:
                processed_count = self.scan_unread_emails(self.inbox)

                if processed_count > 0:
                    logger.info(f"âœ… æœ¬è½®å¤„ç†äº† {processed_count} å°é‚®ä»¶")

                # ç­‰å¾…æŒ‡å®šé—´éš”
                self.stop_event.wait(self.config['monitor']['check_interval'])

            except KeyboardInterrupt:
                logger.info("æ”¶åˆ°åœæ­¢ä¿¡å·ï¼Œæ­£åœ¨é€€å‡º...")
                break
            except Exception as e:
                logger.error(f"ç›‘æ§è¿‡ç¨‹ä¸­å‘ç”Ÿå¼‚å¸¸: {e}")
                self.stop_event.wait(10)  # å¼‚å¸¸åç­‰å¾…10ç§’å†ç»§ç»­


def main():
    try:
        # åŠ è½½é…ç½®
        config = load_config()
        if not config:
            logger.error("âŒ æ— æ³•åŠ è½½é…ç½®æ–‡ä»¶ï¼Œç¨‹åºé€€å‡º")
            return

        # åˆ›å»ºå¤„ç†å™¨
        handler = EmailToJiraHandler(config)

        # æµ‹è¯•è¿æ¥
        if not handler.test_outlook_connection():
            logger.error("âŒ Outlookè¿æ¥å¤±è´¥ï¼Œç¨‹åºé€€å‡º")
            return

        if not handler.test_jira_connection():
            logger.error("âŒ Jiraè¿æ¥å¤±è´¥ï¼Œç¨‹åºé€€å‡º")
            return

        logger.info("ğŸ¯ å¼€å§‹ç›‘æ§é‚®ä»¶...")
        logger.info(f"ğŸ“§ ç›®æ ‡é‚®ç®±: {handler.target_email}")
        logger.info(f"ğŸ” è§¦å‘æ¡ä»¶: é‚®ä»¶å†…å®¹ä»¥@jiraå¼€å¤´")
        logger.info(f"ğŸ“ é™„ä»¶æ”¯æŒ: {'å¯ç”¨' if config['attachments']['enabled'] else 'ç¦ç”¨'}")

        if config['attachments']['enabled']:
            logger.info(f"ğŸ“ ä¸´æ—¶ç›®å½•: {config['attachments']['temp_dir']}")
            logger.info(f"ğŸ“ å¤§å°é™åˆ¶: {config['attachments']['max_size_mb']} MB")
            logger.info(f"ğŸ”¢ æ•°é‡é™åˆ¶: {config['attachments']['max_count']} ä¸ª")

        # å¼€å§‹ç›‘æ§
        handler.start_monitoring()

    except KeyboardInterrupt:
        logger.info("\nğŸ‘‹ æ”¶åˆ°é€€å‡ºä¿¡å·ï¼Œæ­£åœ¨åœæ­¢...")
    except Exception as e:
        logger.error(f"ç¨‹åºå¼‚å¸¸: {e}")
    finally:
        if 'handler' in locals():
            handler.stop_monitoring()
        logger.info("ğŸ”š ç¨‹åºå·²é€€å‡º")


if __name__ == "__main__":
    main()



























email_to_jira_config.jsonæ–‡ä»¶ä¿®æ”¹ï¼š
{
  "jira": {
    "base_url": "https://your-jira-instance.com",
    "username": "your-username",
    "password": "your-password",
    "project": "PROJECT_KEY",
    "issue_type_id": "10004",
    "default_completion_criteria": "é—®é¢˜è§£å†³å¹¶éªŒè¯é€šè¿‡",
    "default_department": "ITéƒ¨é—¨",
    "default_module": "ç³»ç»Ÿç»´æŠ¤",
    "default_category": "ç¼ºé™·ä¿®å¤"
  },
  "monitor": {
    "check_interval": 30
  },
  "attachments": {
    "enabled": true,
    "temp_dir": "temp_attachments",
    "max_size_mb": 500,
    "max_count": 5,
    "allowed_extensions": [".jpg", ".png", ".pdf", ".docx", ".xlsx", ".txt", ".log"]
  },
  "mark_as_read": true
}

